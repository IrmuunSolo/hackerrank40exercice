# Lily's Homework


[![]( https://img.shields.io/badge/Бодлогын_линк-blue)](https://www.hackerrank.com/challenges/lilys-homework/problem?isFullScreen=false)

## Бодлогын тайлбар

Жорж Лилигэй хамт цагийг өнгөрүүлэхийг хүсдэг боловч Лили үргэлж гэрийн даалгавраа хийж байдаг. Жорж түүнд даалгавраа хурдан дуусгахад нь туслахыг хүсч байгаа ч өөрөө ойлгомжгүй байна. Та Жоржд туслаж чадах уу?

Ялгаатай n бүхэл тооноос бүрдсэн arr=[a[0],a[1],…,a[n−1]] массив өгөгдсөн. Жорж массивын аль ч хоёр элементийг хэдэн ч удаа сольж болно. Массив нь 0<i<n байх бүх i-д зориулсан ∣arr[i]−arr[i−1]∣ ялгавруудын нийлбэр хамгийн бага байх үед гоё хэмээн тооцогдоно.

Массив arr өгөгдсөн үед, массивыг гоё болгохын тулд хийх шаардлагатай хамгийн бага солилтын тоог олж буцаана.

**Жишээ:**

arr=[7,15,12,3]

Нэг боломжит гоё массив нь [3,7,12,15] юм. Үүнийг авахын тулд Жорж дараах солилтуудыг хийсэн:

| Солилт |  Үр дүн  |
|:-----|:--------:|
|    | [7, 15, 12, 3] | 
| 3 7   |  [3, 15, 12, 7]  |   
| 7 15   | [3, 7, 12, 15] | 

Массивыг гоё болгохын тулд 2 солилт хийсэн. Энэ нь боломжит бүх гоё массивуудад хамгийн бага солилтын тоо юм.

**Функцийн тодорхойлолт:**

Доорх редактор дахь lilysHomework функцийг гүйцээн бөглөнө үү.

lilysHomework нь дараах параметрүүдтэй:

- int arr[n]: бүхэл тоон массив

**Буцаах утга:**

- int: шаардлагатай хамгийн бага солилтын тоо

**Оролтын формат:**

Эхний мөрөнд массивын элементийн тоо n байна. Хоёр дахь мөрөнд n ширхэг зайгаар тусгаарлагдсан бүхэл тоонууд arr[i] байна.

**Хязгаарлалт:**

- 1≤n≤10^5
- 1≤arr[i]≤2×10^9

**Жишээ оролт:**

```
4
2 5 3 1
```

**Жишээ гаралт:**

```
2
```

Тайлбар:

Гоё дараалал болох arr’=[1,2,3,5]-г тодорхойлъё. Энэ нь arr-ийн зэрэгцээ элементүүдийн ялгавруудын абсолют утгуудын нийлбэр хамгийн бага байх дараалал юм. Үүнийг хийхийн тулд зөвхөн хоёр солилт (эхлээд 1-ийг 2-той, дараа нь 2-ыг 5-тай) хийсэн.

## Бодолт:

1. Гоё массивыг тодорхойлох:

Гоё массив нь эрэмбэлэгдсэн (өсөх эсвэл буурах) дараалал байх ёстой, учир нь энэ нь зэргэлдээ элементүүдийн ялгавруудын нийлбэрийг хамгийн бага болгодог.

2. Хамгийн бага солилтын тоог олох:

- Массивыг өсөх дарааллаар эрэмбэлэхэд шаардагдах солилтын тоог олно.
- Мөн буурах дарааллаар эрэмбэлэхэд шаардагдах солилтын тоог олно.
- Эдгээр хоёрын минимумыг буцаана.

```
        int swapsAsc = countSwaps(new ArrayList<>(arr), sortedAsc);
        int swapsDesc = countSwaps(new ArrayList<>(arr), sortedDesc);
```

3. Солилтын тоог тооцоолох:

- Эхний массив болон эрэмбэлэгдсэн массивыг харьцуулж, элементүүдийн байрлалыг зөв олохын тулд hash map ашиглана.
- Хэрэв элемент буруу байрлалд байгаа бол зөв байрлал руу нь солихдоо солилтын тоог нэмэгдүүлнэ.

```
    private static int countSwaps(List<Integer> arr, List<Integer> target) {
        Map<Integer, Integer> valueToIndex = new HashMap<>();
        for (int i = 0; i < arr.size(); i++) {
            valueToIndex.put(arr.get(i), i);
        }
        
        int swaps = 0;
        for (int i = 0; i < arr.size(); i++) {
            if (!arr.get(i).equals(target.get(i))) {
                swaps++;
                int correctValue = target.get(i);
                int currentIndex = valueToIndex.get(correctValue);
                
                // Swap values in the array
                Collections.swap(arr, i, currentIndex);
                
                // Update the indices in the map
                valueToIndex.put(arr.get(currentIndex), currentIndex);
                valueToIndex.put(arr.get(i), i);
            }
        }
        return swaps;
    }
```


## Submit screenshot

![Submit](/images/38.submit.png)

