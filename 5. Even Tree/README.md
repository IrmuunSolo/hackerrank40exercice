# Even Tree

[![]( https://img.shields.io/badge/Бодлогын_линк-blue)](https://www.hackerrank.com/challenges/even-tree/problem?isFullScreen=false)

## Бодлогын тайлбар

Та нарт мод (ямар ч циклгүй энгийн холбогдсон граф) өгөгдсөн. Энэ модоос ирмэгүүдийг хамгийн их хэдэн ширхэгийг арилгаж, үлдсэн хэсэг бүрт тэгш тооны орой агуулсан ой (forest) үүсгэх шаардлагатай.

Жишээ нь:

![LeetCode Screenshot](/images/5.tree1.png)

4 оройтой модны хувьд 1 ирмэгийг арилгаснаар 2 оройтой 2 хэсэгт хуваагдана.

Функцийн тодорхойлолт:

evenForest функцийг гүйцээх шаардлагатай. Энэ функц дараах параметрүүдийг авна:

- t_nodes: модны оройн тоо
- t_edges: модны ирмэгүүдийн тоо
- t_from: ирмэгүүдийн эхлэх оройнуудын жагсаалт
- t_to: ирмэгүүдийн төгсгөлийн оройнуудын жагсаалт (t_from-ын индексүүдтэй тохирно)

Оролтын формат:

Эхний мөрөнд t_nodes (оройн тоо) ба t_edges (ирмэгүүдийн тоо) гэсэн 2 бүхэл тоо өгөгдөнө. Дараагийн t_edges мөрөнд t_from[i] ба t_to[i] гэсэн модны ирмэгүүдийг тодорхойлсон оройнууд өгөгдөнө. Модны үндэс нь 1 дугаар орой юм.

Хязгаарлалт:

2≤n≤100

n нь тэгш тоо (Zeven^+)

Анхаар: Оролтод өгөгдсөн мод үргэлж тэгш тооны оройтой хэсгүүдэд хуваагдах боломжтой байх болно.

Гаралтын формат:
Арилгасан ирмэгүүдийн тоог хэвлэнэ.

Жишээ оролт 1:

```
10 9
2 1
3 1
4 3
5 2
6 1
7 2
8 6
9 8
10 8
```

![LeetCode Screenshot](/images/5.tree2.png)

(Жишээ оролтыг дээрх тайлбараас харж болно)

Жишээ гаралт 1:

```
2
```

Тайлбар 1:

(1,3) ба (1,6) ирмэгүүдийг арилгаснаар хүссэн үр дүн гарна.

![LeetCode Screenshot](/images/5.tree3.png)

Эндээс өөр ирмэг арилгах боломжгүй.  

## Функцийн тайлбар:

Энэ бодлого нь мод (tree) бүтцийг өгөгдсөн тооны ирмэгүүдийг хасахад үлдсэн бүрдүүлэгч хэсгүүд нь тэгш тооны оройтой байхаар хамгийн их хэдэн ирмэг хасаж болохыг олох.

Аргачлал

- Модыг илэрхийлэх: Модыг adjacency list (хөрш зэргэлдээ оройнуудын жагсаалт) хэлбэрээр хадгална.

```
Map<Integer, List<Integer>> tree = new HashMap<>();
        for (int i = 0; i < t_edges; i++) {
            int u = t_from.get(i);
            int v = t_to.get(i);
            tree.computeIfAbsent(u, k -> new ArrayList<>()).add(v);
            tree.computeIfAbsent(v, k -> new ArrayList<>()).add(u);
        }
```

- Дэд модны хэмжээг тооцоолох: Depth-First Search (DFS) алгоритм ашиглан модны бүх оройн дэд модны хэмжээг (subtree size) тооцоолно. Дэд модны хэмжээ гэдэг нь тухайн орой болон түүний доорх бүх оройнуудын тоо юм.

```
private static void dfs(int node, Map<Integer, List<Integer>> tree, int[] subtreeSizes, boolean[] visited) {
        visited[node] = true;
        // Оройг тооцоонд оруулах
        subtreeSizes[node] = 1;

        // Бүх хөрш оройнуудыг шалгах
        for (int neighbor : tree.getOrDefault(node, new ArrayList<>())) {
            if (!visited[neighbor]) {
                dfs(neighbor, tree, subtreeSizes, visited);
                // Хөршийн дэд модны хэмжээг нэмэх
                subtreeSizes[node] += subtreeSizes[neighbor];
            }
        }
    }
```

- Зөв ирмэгүүдийг тоолох: Хэрэв оройн дэд модны хэмжээ тэгш тоо байвал тэр оройг эцэгтэйгээ холбосон ирмэгийг хасаж болно. Учир нь ирмэгийг хасвал үлдэх хэсэг нь тэгш тооны оройтой байна.

```
int count = 0;
        for (int i = 2; i <= t_nodes; i++) {
            if (subtreeSizes[i] % 2 == 0) {
                count++;
            }
        }
        return count;
```

## Submit screenshot

![submit](/images/5.submit.png)