# Waiter

[![]( https://img.shields.io/badge/Бодлогын_линк-blue)](https://www.hackerrank.com/challenges/waiter/problem?isFullScreen=true)

## Бодлогын тайлбар

Та нэг үдэшлэгийн зоогийн газар дахь үйлчлэгч юм. Дугаарлагдсан хавтангуудыг овоолсон байна. Хариултын хоосон массив үүсгэ. Давталт бүрд, i-р алхамд овоолсон хавтангуудыг дээрээс нь доошоо дарааллаар авч үз. Хэрэв хавтангийн дугаар i-р анхны тоонд хуваагдаж байвал B овоолгод, үгүй бол A овоолгод хий. B овоолгын утгуудыг дээрээс доошоо хариултын массивт хадгална. Дараагийн давталтад A овоолгын утгуудад дээрх үйлдлийг давтана. Шаардлагатай давталтууд дууссаны дараа A овоолгонд үлдсэн утгуудыг дээрээс доошоо хариултын массивт хадгална. Эцэст нь хариултын массивыг буцаана.

**Жишээ:**

A = [2, 3, 4, 5, 6, 7]\
q = 3\
Анхны тоонуудын товчилсон жагсаалт: [2, 3, 5, 7, 11, 13]. Хавтангуудыг урвуу дарааллаар овоолно.\
A0 = [2, 3, 4, 5, 6, 7]\
answers = []

Давталтуудыг эхлүүлнэ. Эхний давталтад 2-т хуваагдаж байгаа эсэхийг шалгана.\
A1 = [7, 5, 3]\
B1 = [6, 4, 2]\
B1-ийн элементүүдийг answers руу шилжүүлнэ.\
answers = [2, 4, 6]

Хоёр дахь давталтад A1-ийн элементүүд 3-т хуваагдаж байгаа эсэхийг шалгана.\
A2 = [7, 5]\
B2 = [3]\
B2-ийн элементүүдийг answers руу шилжүүлнэ.\
answers = [2, 4, 6, 3]

Гурав дахь давталтад A2-ийн элементүүд 5-т хуваагдаж байгаа эсэхийг шалгана.\
A3 = [7]\
B3 = [5]\
B3-ийн элементүүдийг answers руу шилжүүлнэ.\
answers = [2, 4, 6, 3, 5]

Бүх давталтууд дууссан тул A3-д үлдсэн элементүүдийг дээрээс доошоо answers руу шилжүүлнэ.\
answers = [2, 4, 6, 3, 5, 7]. Энэ жагсаалтыг буцаана.

## Бодолт

Энэ бодлогын гол санаа нь давталт бүрд өгөгдсөн анхны тоогоор хуваагдах хавтангуудыг ялгаж, тусгай дарааллаар хариултын массивт хадгалах явдал юм. Үүнийг хэрэгжүүлэхдээ дараах алхмуудыг хийх хэрэгтэй:

1. Анхны тоонуудын жагсаалт бэлтгэх: q ширхэг анхны тоог олох хэрэгтэй. 

2. Давталт хийх: q удаа давталт хийж, давталт бүрд тухайн алхамд харгалзах анхны тоогоор хуваагдах эсэхийг шалгана.
```
    private static List<Integer> getPrimes(int q) {
        List<Integer> primes = new ArrayList<>();
        int num = 2;
        while (primes.size() < q) {
            if (isPrime(num)) {
                primes.add(num);
            }
            num++;
        }
        return primes;
    }
    
```

3. A ба B овоолгуудыг шинэчлэх: Хуваагдах хавтангуудыг B овоолгод, хуваагддаггүй хавтангуудыг A овоолгод хийнэ.
```
        List<Integer> answers = new ArrayList<>();
        List<Integer> primes = getPrimes(q);
        Stack<Integer> A = new Stack<>();
        // Push all numbers to A in original order (top is first element)
        for (int i = 0; i < number.size(); i++) {
            A.push(number.get(i));
        }
```

4. Хариултыг бүрдүүлэх: B овоолгын элементүүдийг дээрээс доошоо хариултын массивт нэмнэ.
```
        for (int i = 0; i < q; i++) {
            int prime = primes.get(i);
            Stack<Integer> newA = new Stack<>();
            Stack<Integer> B = new Stack<>();
            
            while (!A.isEmpty()) {
                int plate = A.pop();
                if (plate % prime == 0) {
                    B.push(plate);
                } else {
                    newA.push(plate);
                }
            }
```

5. Үлдсэн элементүүдийг нэмэх: Бүх давталт дууссаны дараа A овоолгонд үлдсэн элементүүдийг дээрээс доошоо хариултын массивт нэмнэ.
```
            while (!B.isEmpty()) {
                answers.add(B.pop());
            }
            
            A = newA;
        }
        
        // Add remaining elements in A to answers (top to bottom)
        while (!A.isEmpty()) {
            answers.add(A.pop());
        }
        
        return answers;
```


## Submit screenshot

![Submit](/images/31.submit.png)

