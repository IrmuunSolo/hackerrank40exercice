# Non-Divisible Subset

[![]( https://img.shields.io/badge/Бодлогын_линк-blue)](https://www.hackerrank.com/challenges/non-divisible-subset/problem?isFullScreen=true)

## Бодлогын тайлбар

Өгөгдсөн ялгаатай бүхэл тоонуудын олонлог S ба хуваагч k-ийн хувьд S-ийн дэд олонлогийн хамгийн том хэмжээг олно. Энэ дэд олонлогт байгаа аль ч хоёр тооны нийлбэр нь k-д хуваагдахгүй байх ёстой.

**Жишээ**

S=[19,10,12,10,24,25,22],k=4

Үүсгэж болох дэд олонлогуудын нэг нь [0]=[10,12,25]. Өөр нэг дэд олонлог нь [1]=[19,22,24]. Бүх боломжит дэд олонлогуудыг шалгасны дараа хамгийн олон элементтэй дэд олонлогийн хэмжээ 3 байна.

**Функцийн Тодорхойлолт**

Энэ функц нь дараах параметрүүдийг авна:

- S[n]: бүхэл тоонуудын массив
- k: хуваагч

**Буцаах Утга**

- int: S-ийн дэд олонлогийн хамгийн урт хэмжээ

Оролтын Формат

Эхний мөрөнд n ба k гэсэн 2 тоо зайгаар тусгаарлагдан өгөгдөнө. Хоёр дахь мөрөнд n ширхэг ялгаатай бүхэл тоонууд зайгаар тусгаарлагдан өгөгдөнө.

## Бодолт

1. Асуудлыг Ойлгох: Энэ асуудалд S олонлогийн дэд олонлогийг олох хэрэгтэй бөгөөд энэ дэд олонлогийн аль ч хоёр элементийн нийлбэр k-д хуваагдахгүй байх ёстой.

2. S дахь тоо бүрийг k-д хуваахад гарах үлдэгдлийг тооцоолно. Дараа нь үлдэгдэл бүрийн давтамжийг тоолно.

```
        int[] remainderCounts = new int[k];
        for (int num : s) {
            remainderCounts[num % k]++;
        }
```

3. Үлдэгдлийг Сонгох:

- Тэг үлдэгдэл: Зөвхөн нэг тоог сонгоно, учир нь хоёр тэг үлдэгдэлтэй тооны нийлбэр k-д хуваагдана.

- Тэгш k-ийн хувьд k/2 үлдэгдэл: Зөвхөн нэг тоог сонгоно, учир нь хоёр ийм тооны нийлбэр k-д хуваагдана.

- Бусад үлдэгдэл: i ба k−i үлдэгдлийн аль нэгийг сонгоно, учир нь эдгээрийн нийлбэр k-д хуваагдана. Их давтамжтай үлдэгдлийг сонгоно.

4. Хариу Тооцоолох: Сонгосон үлдэгдлийн давтамжуудыг нэмээд хамгийн их дэд олонлогийн хэмжээг олно.

```
        if (k % 2 == 0) {
            int halfK = k / 2;
            if (remainderCounts[halfK] > 0) {
                maxSize += 1;
            }
            // Iterate from 1 to halfK - 1
            for (int i = 1; i < halfK; i++) {
                maxSize += Math.max(remainderCounts[i], remainderCounts[k - i]);
            }
        } else {
            // Iterate from 1 to k/2 (integer division)
            for (int i = 1; i <= k / 2; i++) {
                maxSize += Math.max(remainderCounts[i], remainderCounts[k - i]);
            }
        }
```

## Submit screenshot

![Submit](/images/9.submit.png)