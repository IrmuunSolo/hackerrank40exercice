# Almost Sorted

[![]( https://img.shields.io/badge/Бодлогын_линк-blue)](https://www.hackerrank.com/challenges/almost-sorted/problem?isFullScreen=false)

## Бодлогын тайлбар

Танд бүхэл тооноос бүрдсэн массив өгөгдсөн. Энэ массивыг зөвхөн дараах хоёр үйлдлийн аль нэгийг нь нэг удаа хийснээр өсөх дарааллаар эрэмбэлэх боломжтой эсэхийг тодорхойлох хэрэгтэй.

1. Хоёр элементийг солих (swap)

2. Нэг дэд сегментийг урвуулах (reverse)

араах дүрмийн дагуу хариуг хэвлэнэ.

1. Хэрэв массив аль хэдийн эрэмбэлэгдсэн байвал эхний мөрөнд yes гэж хэвлэнэ. Өөр юм хэвлэх шаардлагагүй.

2. Хэрэв массивыг зөвхөн нэг үйлдлээр (хоёрын аль нэгээр) эрэмбэлэх боломжтой бол эхний мөрөнд yes, дараагийн мөрөнд:

- Хэрэв зөвхөн солих боломжтой бол swap l r гэж хэвлэнэ. Энд l ба r нь солих элементийн индексууд (массивын индекс 1-ээс эхэлнэ).
- Хэрэв зөвхөн урвуулах боломжтой бол reverse l r гэж хэвлэнэ. Энд l ба r нь урвуулах дэд сегментийн эхний ба сүүлийн индексууд.
- Хэрэв хоёр үйлдлээр эрэмбэлэх боломжтой бол солих үйлдлийг сонгоно.

3. Хэрэв массивыг аль ч аргаар эрэмбэлэх боломжгүй бол эхний мөрөнд no гэж хэвлэнэ.

**Жишээ:**

arr = [2, 3, 5, 4]

- 3 ба 4-р индексийн элементүүдийг (5 ба 4-ийг) сольж эрэмбэлэх боломжтой.
- Эсвэл 3-4 индексийн дэд сегментийг урвуулах (5, 4 → 4, 5) боломжтой.
- Гэхдээ солих үйлдлийг илүүд үзнэ. Тиймээс:

```
yes
swap 3 4
```

## Бодолт:

1. Массив эрэмбэлэгдсэн эсэхийг шалгах:

- Хэрэв массив өсөх дарааллаар байгаа бол шууд yes гэж хэвлэнэ.

```
        List<Integer> sorted = new ArrayList<>(arr);
        Collections.sort(sorted);
        
        if (arr.equals(sorted)) {
            System.out.println("yes");
            return;
        }
```

2. Солих (swap) боломжийг шалгах:

- Эрэмбэлэгдсэн массивтай харьцуулахад зөвхөн хоёр элемент байрлалаа солих шаардлагатай байгаа эсэхийг шалгана.
- Хэрэв тийм бол тэдгээр элементийн индексийг олж swap l r гэж хэвлэнэ.

```
        for (int i = 0; i < n; i++) {
            if (arr.get(i) != sorted.get(i)) {
                left = i;
                break;
            }
        }
        for (int i = n - 1; i >= 0; i--) {
            if (arr.get(i) != sorted.get(i)) {
                right = i;
                break;
            }
        }
```

3. Урвуулах (reverse) боломжийг шалгах:

- Хэрэв массивын зөвхөн нэг дэд сегмент буурах дарааллаар байгаа бөгөөд түүнийг урвуулахад бүх массив эрэмбэлэгдэх боломжтой эсэхийг шалгана.
- Хэрэв тийм бол тухайн дэд сегментийн индексийг олж reverse l r гэж хэвлэнэ.

```
        temp = new ArrayList<>(arr);
        List<Integer> sublist = temp.subList(left, right + 1);
        Collections.reverse(sublist);
        if (temp.equals(sorted)) {
            System.out.println("yes");
            System.out.println("reverse " + (left + 1) + " " + (right + 1));
            return;
        }
```

4. Хэрэв аль ч аргаар эрэмбэлэх боломжгүй бол no гэж хэвлэнэ.

```
        System.out.println("no");
    }
```

## Submit screenshot

![Submit](/images/36.submit.png)

