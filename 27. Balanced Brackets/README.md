# Balanced Brackets

[![]( https://img.shields.io/badge/Бодлогын_линк-blue)](https://www.hackerrank.com/challenges/balanced-brackets/problem?isFullScreen=true)

## Бодлогын тайлбар

Хаалт гэдэг нь дараах тэмдэгтүүдийн аль нэгийг хэлнэ: (, ), {, }, [, ].

Хоёр хаалтыг харгалзах хос гэж үзнэ, хэрэв нээх хаалт (жишээ нь (, [, {) хаах хаалтын (жишээ нь ), ], }) яг ижил төрлийнхний зүүн талд гарч ирсэн бол. Гурван төрлийн харгалзах хаалтууд байна: [], {}, ().

Хэрэв хаалтуудын дотор байгаа хаалтууд зөв харгалзаагүй бол тэр хосыг тэнцвэртэй гэж үзэхгүй. Жишээлбэл, {[(])} нь тэнцвэртэй биш, учир нь { ба } хооронд байгаа хаалтууд тэнцвэртэй биш. Квадрат хаалтууд [ ] дотор тэнцвэргүй нээх дугуй хаалт (, харин дугуй хаалт ( ) дотор тэнцвэргүй хаах квадрат хаалт ] байна.

Хаалтуудын дараалал дараах нөхцлүүдийг хангаж байвал тэнцвэртэй гэж үзнэ:

1. Харгалзахгүй хаалт байхгүй

2. Харгалзах хос хаалтуудын дотор байгаа хаалтууд мөн харгалзах хос байх

Өгөгдсөн n ширхэг хаалтуудын дараалал бүрийг тэнцвэртэй эсэхийг шалга. Хэрэв тэнцвэртэй бол "YES", эсрэг тохиолдолд "NO" гэж буцаа.

Функцийн тодорхойлолт:
isBalanced функцийг доорх редакторт гүйцээнэ үү.
isBalanced нь дараах параметртэй:

- string s: хаалтуудын дараалал
Буцаах утга:
- string: "YES" эсвэл "NO"

**Оролтын формат:**

Эхний мөрөнд n бүхэл тоо (хэдэн мөр хаалт өгөгдөх вэ).
Дараагийн n мөр бүрд хаалтуудын дараалал s өгөгдөнө.

**Хязгаарлалт:**

- 1 ≤ n ≤ 10^3
- 1 ≤ s ≤ 10^3 (s-ийн урт)
- Бүх тэмдэгтүүд {, }, (, ), [, ] эдгээрээс бүрдэнэ.

**Гаралтын формат:**

Мөр бүрийн хариуг "YES" эсвэл "NO" гэж хэвлэ.

**Жишээ оролт:**

```
3
{[()]}
{[(])}
{{[[(())]]}}
```

**Жишээ гаралт:**

```
YES
NO
YES
```

**Тайлбар:**

1. {[()]} мөр нь тэнцвэртэй байх хоёр нөхцлийг хангаж байна.

2. {[(])} мөр нь тэнцвэртэй биш, учир нь { ба } хоорондох [(]) хэсэг тэнцвэртэй биш.

3. {{[[(())]]}} мөр нь тэнцвэртэй байх хоёр нөхцлийг хангаж байна.

## Бодолт

Энэ бодлогыг шийдэхийн тулд stack (бутархай жагсаалт) өгөгдлийн бүтцийг ашиглана. Алгоритм нь:

1. Хаалт бүрийг дараалан шалгана

2. Нээх хаалт ([{ бол stack-д хийх

```
        Stack<Character> stack = new Stack<>();
        
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);
            }
```

3. Хаах хаалт )]} бол stack-аас сүүлд орсон хаалтыг шалгах:

  - Харгалзах нээх хаалт байвал stack-аас хасах
  - Харгалзахгүй бол тэнцвэргүй гэж үзэх

4. Бүх хаалтыг шалгасны дараа stack хоосон биш бол тэнцвэргүй

```
           } else {
                if (stack.isEmpty()) {
                    return "NO";
                }
                
                char top = stack.pop();
                if (!((c == ')' && top == '(') || 
                      (c == ']' && top == '[') || 
                      (c == '}' && top == '{'))) {
                    return "NO";
                }
            }
```

## Submit screenshot

![Submit](/images/27.submit.png)

