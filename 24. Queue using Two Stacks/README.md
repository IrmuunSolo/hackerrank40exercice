# Queue using Two Stacks

[![]( https://img.shields.io/badge/Бодлогын_линк-blue)](https://www.hackerrank.com/challenges/queue-using-two-stacks/problem?isFullScreen=true)

## Бодлогын тайлбар

Дараалал (Queue) гэдэг нь элементүүдийг нэмсэн дарааллаар нь хадгалдаг, хамгийн эрт нэмэгдсэн элементийг урд талаас нь хасаж, шинэ элементийг хойд талд нь нэмдэг өгөгдлийн бүтэц юм. Үүнийг Эхдээ-Ороод-Эхдээ-Гарах (FIFO) бүтэц гэж нэрлэдэг, учир нь эхний нэмэгдсэн элемент (хамгийн урт хүлээсэн) үргэлж эхнийх нь хасагддаг.

Дараалалд дараах үйлдлүүдийг гүйцэтгэдэг:

- Нэмэх (Enqueue): Дарааллын төгсгөлд шинэ элемент нэмнэ.
- Хасах (Dequeue): Дарааллын урд талын элементийг хасаж, буцаана.

Энэхүү бодлогын хувьд та эхлээд хоёр стек ашиглан дарааллыг хэрэгжүүлэх ёстой. Дараа нь q ширхэг хүсэлтийг боловсруулна. Хүсэлт бүр дараах 3 төрлийн аль нэг байна:

1. 1 x: x элементийг дарааллын төгсгөлд нэмнэ.
2. 2: Дарааллын урд талын элементийг хасна.
3. 3: Дарааллын урд талын элементийг хэвлэнэ.

**Оролтын формат:**

- Эхний мөрөнд q (хүсэлтийн тоо) байна.
- Дараагийн q мөр бүрт дээрх 3 төрлийн хүсэлтийн аль нэгийг оруулна. Зөвхөн 1-р төрлийн хүсэлтийн ард x утга байх бөгөөд энэ нь дараалалд нэмэгдэх утга юм.

**Хязгаарлалт:**

- 1≤q≤10^5
- 1≤type≤3
- 1≤∣x∣≤10^9

3-р төрлийн хүсэлт бүрт хүчинтэй хариу үргэлж байх баталгаатай.

**Гаралтын формат:**

3-р төрлийн хүсэлт бүрийн хувьд дарааллын урд талын элементийг шинэ мөрөнд хэвлэнэ.

**Жишээ оролт:**

```
10
1 42
2
1 14
3
1 28
3
1 60
1 78
2
2
```

**Жишээ гаралт:**

```
14
14
```

**Тайлбар:**

Дараах дарааллаар үйлдлүүдийг гүйцэтгэнэ:

1. 42-г нэмнэ; queue={42}.
2. Дарааллын урд талын 42-г хасна; queue={}.
3. 14-г нэмнэ; queue={14}.
4. Дарааллын урд талын 14-г хэвлэнэ; queue={14}.
5. 28-г нэмнэ; queue={14,28}.
6. Дарааллын урд талын 14-г хэвлэнэ; queue={14,28}.
7. 60-г нэмнэ; queue={14,28,60}.
8. 78-г нэмнэ; queue={14,28,60,78}.
9. Дарааллын урд талын 14-г хасна; queue={28,60,78}.
10. Дарааллын урд талын 28-г хасна; queue={60,78}.
\

## Бодолт:

**Тайлбар:**

1. stack1 болон stack2 гэсэн хоёр стек ашиглана.

```
    private static Stack<Integer> stack1 = new Stack<>();
    private static Stack<Integer> stack2 = new Stack<>();
```

2. Нэмэх (enqueue): Элементийг stack1-д оруулна.

```
    private static void enqueue(int x) {
        stack1.push(x);
    }

```

3. Хасах (dequeue):

- Хэрэв stack2 хоосон бол stack1-ийн бүх элементийг stack2-д шилжүүлнэ. Энэ нь дарааллын урд талын элементийг stack2-ийн оройд байрлуулах зорилготой.
- Дараа нь stack2-ийн оройн элементийг хасна.

```
    private static void dequeue() {
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        stack2.pop();
    }
```

4. Хэвлэх (printFront):

- stack2 хоосон үед stack1-ийн элементүүдийг stack2-д шилжүүлнэ.
- stack2-ийн оройн элементийг хэвлэнэ.

```
    private static void printFront() {
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        System.out.println(stack2.peek());
    }
```



## Submit screenshot

![Submit](/images/24.submit.png)

