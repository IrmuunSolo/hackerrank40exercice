# Bigger is Greater

[![]( https://img.shields.io/badge/Бодлогын_линк-blue)](https://www.hackerrank.com/challenges/bigger-is-greater/problem?isFullScreen=true)

## Бодлогын тайлбар

Энэхүү бодлогын зорилго нь өгөгдсөн үгээс үсгүүдийн байрлалыг солих замаар анхны үгээс лексикографын дарааллаар (үсгийн дарааллаар) арай том, гэхдээ хамгийн жижиг боломжит үгийг олох явдал юм. Хэрэв ийм үг олдохгүй бол "no answer" гэж хариулах ёстой.

Лексикографын дараалал гэдэг нь үсгүүдийг цагаан толгойн дарааллаар эрэмбэлсэнтэй төстэй. Жишээлбэл, "abdc" нь "abcd"-ээс том гэж тооцогдоно, учир нь эхний хоёр үсэг ижил байхад гурав дахь үсэг 'd' нь 'b'-ээс цагаан толгойн дарааллаар хойно оршдог.

**Функцийн Тодорхойлолт**

Энэ функц нь дараах параметрүүдийг авна:

- string w: үг

**Буцаах утга**

- string: лексикографын дарааллаар (үсгийн дарааллаар) арай том, гэхдээ хамгийн жижиг боломжит үг

**Жишээ 0 оролт**

```
5
ab
bb
hefg
dhck
dkhc
```

**Гаралт**

```
ba
no answer
hegf
dhkc
hcdk
```

**Бодолт**

1. Өгөгдсөн үгийн төгсгөлөөс эхлэн харгалзах үсгүүдийг харьцуулж, эхний удаа өмнөх үсгээсээ бага үсэг олдох хүртэл шалгана. Энэ үсэг нь дараагийн том үгийг бүтээхэд гол үүрэг гүйцэтгэнэ. Хэрэв ийм үсэг олдохгүй бол тухайн үг нь аль хэдийн лексикографын дарааллаар хамгийн их утгатай байгаа тул "no answer" гэж хариулна.

```
        for (int i = n - 2; i >= 0; i--) {
            if (chars[i] < chars[i + 1]) {
                pivot = i;
                break;
            }
        }

        if (pivot == -1) {
            return "no answer";
        }
```

2. Солих үсгийг олох: Pivot-ийг олсны дараа дахин төгсгөлөөс эхлэн pivot-ээс том хамгийн баруун талын үсгийг олно. Энэ хоёр үсгийг солино.

```
        int swapIndex = -1;
        for (int i = n - 1; i > pivot; i--) {
            if (chars[i] > chars[pivot]) {
                swapIndex = i;
                break;
            }
        }

        char temp = chars[pivot];
        chars[pivot] = chars[swapIndex];
        chars[swapIndex] = temp;
```

3. Үлдсэн хэсгийг эрэмбэлэх: Pivot-ийн баруун талд байгаа үсгүүдийг өсөх дарааллаар (лексикографын хамгийн бага дараалалд) эрэмбэлнэ. Үүний тулд энэ хэсгийг урвуулахад хангалттай, учир нь энэ хэсэг нь буурах дарааллаар эрэмбэлэгдсэн байдаг.

```
        int left = pivot + 1;
        int right = n - 1;
        while (left < right) {
            temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;
            left++;
            right--;
        }

```

## Submit screenshot

![Submit](/images/10.submit.png)

