# Common Child


[![]( https://img.shields.io/badge/Бодлогын_линк-blue)](https://www.hackerrank.com/challenges/common-child/problem?isFullScreen=true)

## Бодлогын тайлбар

Тэмдэгт мөрийг нөгөө тэмдэгт мөрийн хүү гэж үзнэ, хэрэв эхний тэмдэгт мөрөөс 0 эсвэл түүнээс олон тэмдэгтийг устгаснаар үүсгэж болдог бол. Тэмдэгтүүдийг дахин зохион байгуулахыг зөвшөөрөхгүй.

Ижил урттай хоёр тэмдэгт мөр өгөгдсөн үед, хоёр тэмдэгт мөрийн хамгийн урт нийтлэг хүүгийн уртыг ол.

**Жишээ:**

s1= ′ABCD′

s2= ′ABDC′

Эдгээр тэмдэгт мөрүүдийн хамгийн урт нийтлэг хүү нь урт нь 3 бүхий ABC ба ABD юм. Эдгээрийг хоёр тэмдэгт мөрөөс D эсвэл C-г устгаснаар гаргаж болно. Тиймээс хариу нь 3.

**Функцийн тодорхойлолт:**

commonChild функцийг доорх редакторт гүйцээн бөглөнө үү.

commonChild нь дараах параметрүүдтэй:

- string s1: эхний тэмдэгт мөр
- string s2: хоёр дахь тэмдэгт мөр

**Буцаах утга:**

- int: оролтын тэмдэгт мөрүүдийн хамгийн урт нийтлэг хүүгийн урт

**Оролтын формат:**

Хоёр мөрөнд тус бүр s1 ба s2 тэмдэгт мөрүүд өгөгдөнө.

**Хязгаарлалт:**

- 1≤∣s1∣,∣s2∣≤5000 (Энд ∣s∣ нь тэмдэгт мөрийн урт)
- Бүх тэмдэгтүүд том үсгээр (ASCII [A-Z]) бичигдсэн байна.

**Жишээ оролт:**

```
HARRY  
SALLY  
```

**Жишээ гаралт:**

```
2  
```

**Тайлбар:**

HARRY ба SALLY-аас тэмдэгтүүдийг устгаж гаргаж болох хамгийн урт нийтлэг хүү нь AY бөгөөд урт нь 2.

**Жишээ оролт 1:**

```
AA  
BB  
```

**Жишээ гаралт 1:**

```
0  
```

**Тайлбар 1:**

AA ба BB-д нийтлэг тэмдэгт байхгүй тул хариу нь 0.

**Жишээ оролт 2:**

```
SHINCHAN  
NOHARAAA  
```

**Жишээ гаралт 2:**

```
3  
```

**Тайлбар 2:**

SHINCHAN ба NOHARAAA-д дарааллыг хадгалсан хамгийн урт нийтлэг хүү нь NHA бөгөөд урт нь 3.

**Жишээ оролт 3:**

```
ABCDEF  
FBDAMN  
```

**Жишээ гаралт 3:**

```
2  
```

**Тайлбар 3:**

BD нь өгөгдсөн тэмдэгт мөрүүдийн хамгийн урт нийтлэг хүү юм.

## Бодолт:

Энэ бодлогын гол зорилго нь хоёр тэмдэгт мөрийн хамгийн урт нийтлэг дэд дарааллын (Longest Common Subsequence, LCS) уртыг олох юм. LCS нь хоёр тэмдэгт мөрөнд ижил дарааллаар тохиолддог хамгийн урт дэд дарааллыг хэлнэ.

1. Динамик програмчлал (Dynamic Programming) ашиглах:

- dp[i][j] нь s1-ийн эхний i тэмдэгт ба s2-ийн эхний j тэмдэгтийн LCS уртыг илэрхийлнэ.
- Хэрэв s1.charAt(i-1) == s2.charAt(j-1) бол dp[i][j] = dp[i-1][j-1] + 1.
- Эсрэг тохиолдолд dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]).

```
        int m = s1.length();
        int n = s2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                if (i == 0 || j == 0) {
                    dp[i][j] = 0;
                } else if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
```



## Submit screenshot

![Submit](/images/39.submit.png)

