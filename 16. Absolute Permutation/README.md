# Absolute Permutation

[![]( https://img.shields.io/badge/Бодлогын_линк-blue)](https://www.hackerrank.com/challenges/absolute-permutation/problem?isFullScreen=true)

## Бодлогын тайлбар

Бидэнд n хүртэлх натурал тоонуудын сэлгэмэл (permutation) өгөгдсөн. Энэ сэлгэмэлд байгаа элемент бүрийн байрлал ба утгын ялгавар нь k-тай тэнцүү байх ёстой. Ийм сэлгэмэл олдвол лексикографийн хувьд хамгийн жижигийг нь олж, олдохгүй бол -1 буцаана.

**Жишээ:**

n=4, k=2 үед [3,4,1,2] гэсэн сэлгэмэл нь дараах нөхцлийг хангана:

- ∣3−1∣=2
- ∣4−2∣=2
- ∣1−3∣=2
- ∣2−4∣=2

**Функцийн тодорхойлолт:**

absolutePermutation функцийг гүйцээх шаардлагатай. Энэ функц нь дараах параметрүүдтэй:

- int n: натурал тоонуудын дээд хязгаар
- int k: байрлал ба утгын ялгавар

Буцаах утга:

- List<Integer>: лексикографийн хувьд хамгийн жижиг сэлгэмэл эсвэл [−1]

**Оролтын формат:**

Эхний мөрөнд асуултын тоо t өгөгдөнө.\
Дараагийн t мөр бүрт n ба k өгөгдөнө.

**Хязгаарлалт:**

- 1≤t≤10
- 1≤n≤10^5
- 0≤k<n

**Жишээ оролт:**

```
3
2 1
3 0
3 2
```

**Жишээ гаралт:**

```
2 1
1 2 3
-1
```

Тайлбар:

- Эхний тест: n=2, k=1. Ганц боломжит сэлгэмэл [2,1].

- Хоёр дахь тест: n=3, k=0. Анхны дараалал [1,2,3] нь нөхцлийг хангана.

- Гурав дахь тест: n=3, k=2. Ийм сэлгэмэл байхгүй.

## Бодолт:

1. Тусгай тохиолдлуудыг шалгах:

- Хэрэв k=0 бол анхны дараалал нь шийдэл болно.
- Хэрэв n нь 2k-д хуваагдахгүй бол сэлгэмэл байхгүй.

```
        List<Integer> result = new ArrayList<>();
        if (k == 0) {
            for (int i = 1; i <= n; i++) {
                result.add(i);
            }
            return result;
        }
        if (n % (2 * k) != 0) {
            result.add(-1);
            return result;
        }
```

2. Сэлгэмэл үүсгэх:

- i-р элементийг i+k эсвэл i−k-аар солино.
- Лексикографийн хувьд жижиг сэлгэмэлийг үүсгэхийн тулд эхлээд i+k-г ашиглана.

```
        int[] perm = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            if (perm[i] == 0) {
                perm[i] = i + k;
                perm[i + k] = i;
            }
        }
        for (int i = 1; i <= n; i++) {
            result.add(perm[i]);
        }
        return result;
```

Тайлбар:

1. Тусгай тохиолдлууд:

- k=0 үед анхны дарааллыг буцаана.
- n нь 2k-д хуваагдахгүй бол −1 буцаана.

2. Сэлгэмэл үүсгэх:

- i-р элементийг i+k эсвэл i−k-аар солих замаар сэлгэмэл үүсгэнэ.
- Лексикографийн хувьд жижиг сэлгэмэлийг хангахын тулд эхлээд i+k-г ашиглана.

3. Үр дүнг буцаах: Үүсгэсэн сэлгэмэлийг буцаана. Хэрэв сэлгэмэл байхгүй бол −1 буцаана.

## Submit screenshot

![Submit](/images/16.submit.png)

