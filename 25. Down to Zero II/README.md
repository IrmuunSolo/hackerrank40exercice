# Down to Zero II

[![]( https://img.shields.io/badge/Бодлогын_линк-blue)](https://www.hackerrank.com/challenges/down-to-zero-ii/problem?isFullScreen=true)

## Бодлогын тайлбар

Та Q ширхэг хүсэлт өгөгдсөн. Хүсэлт бүр нь ганц тоо N-ээс бүрдэнэ. Та N-ийг 0 болтол бууруулахын тулд дараах 2 үйлдлийн аль нэгийг сонгон хийж болно:

1. Хэрэв N=a×b (энд a≠1, b≠1) байх 2 бүхэл тоо a ба b олдвол N-ийг max(a,b)-р сольж болно.

2. N-ийг 1-ээр бууруулж болно.

N-ийг 0 болтол бууруулахын тулд хийх хамгийн бага хөдөлмөрийн тоог тодорхойл.

**Оролтын формат:**

- Эхний мөрөнд Q (хүсэлтийн тоо) байна.
- Дараагийн Q мөр бүрт N тоо байна.

**Хязгаарлалт:**

- 1≤Q≤10^3
- 0≤N≤10^6

**Гаралтын формат:**

Q мөр хэвлэнэ. Мөр бүрд N-ийг 0 болтол бууруулахын тулд хийх хамгийн бага хөдөлмөрийн тоог бичнэ.

**Жишээ оролт:**

```
2
3
4
```

**Жишээ гаралт:**

```
3
3
```

**Тайлбар:**

- Эхний тестийн хувьд (N = 3), зөвхөн нэг сонголт байна: 3→2→1→0. Нийт 3 хөдөлмөр.
- Хоёр дахь тестийн хувьд (N = 4), 2 сонголт байна:

  - 4→3→2→1→0 (4 хөдөлмөр)

  - 4→2→1→0 (3 хөдөлмөр) Хоёр дахь сонголт илүү оновчтой тул 3 хөдөлмөр.

## Бодолт:

Энэ бодлогыг динамик програмчлал (Dynamic Programming) ашиглан шийдэж болно. Бид 
d
p
dp нэртэй массив ашиглан 0-ээс 
N
N хүртэлх тоо бүрийг 0 болтол бууруулахад шаардагдах хамгийн бага хөдөлмөрийг хадгална.

1. Алгоритм:

- dp[0]=0 (0-ийг 0 болгоход 0 хөдөлмөр шаардлагатай).
- dp[1]=1 (1-ийг 1-ээр бууруулж 0 болгоно).
- dp[i]-ийг тооцоолохдоо:
  - dp[i]=dp[i−1]+1 (2-р үйлдэл).
  - i-ийн бүх хуваагч a ба b-ийг олж, dp[i]=min(dp[i],dp[max(a,b)]+1) (1-р үйлдэл).

```
    private static void precompute() {
        int maxN = 1_000_000;
        dp = new int[maxN + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 3;

        for (int i = 4; i <= maxN; i++) {
            dp[i] = dp[i - 1] + 1;
            for (int a = 2; a * a <= i; a++) {
                if (i % a == 0) {
                    int b = i / a;
                    dp[i] = Math.min(dp[i], dp[Math.max(a, b)] + 1);
                }
            }
        }
    }
```

2. Хэрэгжүүлэлт:

- Эхлээд dp массивыг бүх N-ийн хувьд бэлдэнэ.
- Хүсэлт бүрт dp[N]-ийг буцаана.

```
    private static int[] dp;

    public static int downToZero(int n) {
        if (dp == null) {
            precompute();
        }
        return dp[n];
    }
```


## Submit screenshot

![Submit](/images/25.submit.png)

