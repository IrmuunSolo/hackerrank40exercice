# Castle on the Grid

[![]( https://img.shields.io/badge/Бодлогын_линк-blue)](https://www.hackerrank.com/challenges/castle-on-the-grid/problem?isFullScreen=true)

## Бодлогын тайлбар

Танд нээлттэй (.) болон хаалттай (X) нүднүүдээс бүрдсэн квадрат сүлжээ өгөгдсөн. Таны тоглоомын хэсэг нь аль ч мөр эсвэл багана дагуу хөдөлж болно, гэхдээ сүлжээний ирмэг эсвэл хаалттай нүдэнд хүртэл л хөдөлнө. Сүлжээ, эхлэх цэг, зорилтот цэг өгөгдсөн бол зорилтот цэгт хүрэх хамгийн бага хөдөлгөөний тоог ол.

**Жишээ:**

```
grid = ['...','.X.','...']
startX = 0
startY = 0
goalX = 1
goalY = 2
```

**Сүлжээ:**

```
...
.X.
...
```

Эхлэх цэг (0, 0) - дээд зүүн булан. Зорилтот цэг (1, 2). Зам нь (0,0) → (0, 2) → (1, 2). Зорилтот цэгт хүрэхэд 2 хөдөлгөөн шаардлагатай.

**Функцийн тодорхойлолт:**

minimumMoves функцийг редакторт гүйцээнэ үү.
minimumMoves нь дараах параметрүүдтэй:

string grid[n]: сүлжээний мөрүүдийг илэрхийлэх тэмдэгт мөрүүдийн массив

- int startX: эхлэх X координат
- int startY: эхлэх Y координат
- int goalX: зорилтот X координат
- int goalY: зорилтот Y координат
Буцаах утга:
- int: зорилтот цэгт хүрэх хамгийн бага хөдөлгөөний тоо

**Оролтын формат:**

Эхний мөрөнд n бүхэл тоо - сүлжээний хэмжээ.
Дараагийн n мөр бүрд n урттай тэмдэгт мөр.
Сүүлийн мөрөнд startX, startY, goalX, goalY гэсэн 4 бүхэл тоо зайгаар тусгаарлагдан өгөгдөнө.

**Хязгаарлалт:**

- 1 ≤ n ≤ 100

- 0 ≤ startX, startY, goalX, goalY < n

**Жишээ оролт:**

```
3
.X.
.X.
...
0 0 0 2
```

**Жишээ гаралт:**

```
3
```

**Тайлбар:**

Зорилтот цэгт 3 алхамаар хүрэх боломжтой зам:
(0,0) → (2, 0) → (2, 2) → (0, 2).

## Бодолт

Энэ бодлогыг BFS (Breadth-First Search) алгоритм ашиглан шийдэж болно. 

1. BFS ашиглах:

- Эхлэх цэгээс эхлэн бүх боломжит чиглэлд хөдөлнө
- Чиглэл бүрт хөдөлж, хаалттай нүд эсвэл хүрээнд хүртэл явна
- Шинэ нүд бүрт хүрэхэд шаардлагатай хөдөлгөөний тоог тэмдэглэнэ

```
        int n = grid.size();
        if (startX == goalX && startY == goalY) return 0;
        
        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        int[][] moves = new int[n][n];
        for (int[] row : moves) Arrays.fill(row, -1);
```

2. Жишээ оролтын шинжилгээ:

- Оролт:

```
.X.
.X.
...
0 0 0 2
```

- Алхамууд:

  1. (0,0) → баруун тийш (0,1) хаалттай → зогсоно
  2. (0,0) → доош (1,0) → (2,0) (1 хөдөлгөөн)
  3. (2,0) → баруун тийш (2,1) → (2,2) (2 хөдөлгөөн)
  4. (2,2) → дээш (1,2) → (0,2) (3 хөдөлгөөн) → зорилтот цэгт хүрлээ

3. Цаг хугацааны хувьд O(n^2) буюу сүлжээний хэмжээтэй шууд хамааралтай, учир нь хамгийн муу тохиолдолд бүх нүдүүдийг шалгах шаардлагатай.

4. Сансрын хувьд O(n^2) шаардлагатай, учир нь хөдөлгөөний тоог хадгалах n x n хэмжээтэй массив ашиглана.


## Submit screenshot

![Submit](/images/28.submit.png)

