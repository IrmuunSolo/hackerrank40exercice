# Connected Cells in a Grid
[![]( https://img.shields.io/badge/Бодлогын_линк-blue)](https://www.hackerrank.com/challenges/connected-cell-in-a-grid/problem?isFullScreen=true)

## Бодлогын тайлбар

Бидэнд n×m хэмжээтэй матриц өгөгдсөн. Матрицын нүд бүрт 0 эсвэл 1 утга байна. 1 утгатай нүдийг дүүргэгдсэн нүд гэнэ. Хэрэв хоёр дүүргэгдсэн нүд хэвтээ, босоо эсвэл диагональ чиглэлд зэргэлдээ байвал тэдгээр нь холбогдсон гэж үзнэ. Холбогдсон дүүргэгдсэн нүднүүд нэг бүсэд (region) багтана. Матрицын хамгийн том бүсэд хэдэн нүд багтаж байгааг олох хэрэгтэй.

**Жишээ:**

Дараах 3×3 матрицыг авч үзье:

```
1 1 0
0 1 0
0 0 1
```

Энд хоёр бүс байна. Эхний бүс (зүүн дээд буланд) 3 нүд, хоёр дахь бүс (баруун доод буланд) 1 нүдтэй. Тиймээс хамгийн том бүс 3 нүдтэй.

**Функцийн тодорхойлолт:**

connectedCell функцийг гүйцээх шаардлагатай. Энэ функц нь дараах параметртэй:

- List<List<Integer>> matrix: n×m хэмжээтэй матриц

**Буцаах утга:**

- int: хамгийн том бүсэд багтах нүдний тоо 

**Оролтын формат:**

Эхний мөрөнд матрицын мөрийн тоо n өгөгдөнө.

Хоёр дахь мөрөнд матрицын баганын тоо m өгөгдөнө.

Дараагийн n мөр бүрт m ширхэг зайгаар тусгаарлагдсан бүхэл тоонууд өгөгдөнө.

**Хязгаарлалт:**

0<n,m<10

**Жишээ оролт:**

```
4
4
1 1 0 0
0 1 1 0
0 0 1 0
1 0 0 0
```

**Жишээ гаралт:**

```
5
```

**Тайлбар:**

Дээрх матрицын хамгийн том бүс 5 нүдтэй. Энэ нь дараах нүднүүдээс бүрдэнэ:

```
X X . .
. X X .
. . X .
Y . . .
```

## Бодолт:

1. Бүх нүдийг шалгах: Матрицын бүх нүдийг дайран өнгөрч, 1 утгатай нүдийг олно.

```
        int maxRegion = 0;
        int n = matrix.size();
        if (n == 0) return 0;
        int m = matrix.get(0).size();
        
        boolean[][] visited = new boolean[n][m];
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix.get(i).get(j) == 1 && !visited[i][j]) {
```

2. Depth-First Search (DFS) эсвэл Breadth-First Search (BFS) хийх: Олдсон 1 утгатай нүднээс эхлэн холбогдсон бүх нүдний тоог тоолно. Энэ үед аль хэдийн тоологдсон нүдийг дахин тоолохгүйн тулд тэмдэглэгээ хийнэ.

```
   private static int dfs(List<List<Integer>> matrix, int i, int j, boolean[][] visited) {
        if (i < 0 || i >= matrix.size() || j < 0 || j >= matrix.get(0).size() || 
            matrix.get(i).get(j) == 0 || visited[i][j]) {
            return 0;
        }
        
        visited[i][j] = true;
        int size = 1;
        
        for (int di = -1; di <= 1; di++) {
            for (int dj = -1; dj <= 1; dj++) {
                if (di == 0 && dj == 0) continue;
                size += dfs(matrix, i + di, j + dj, visited);
            }
        }
        
        return size;
    }
```

3. Хамгийн том бүсийг тодорхойлох: Бүх боломжит бүсүүдийн хэмжээг харьцуулж, хамгийн томыг нь сонгоно.

```
      for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix.get(i).get(j) == 1 && !visited[i][j]) {
                    int regionSize = dfs(matrix, i, j, visited);
                    maxRegion = Math.max(maxRegion, regionSize);
                }
            }
        }
        
        return maxRegion;
    }
```

**Тайлбар:**

1. Матрицыг унших: Оролтыг уншиж, матрицыг бүрдүүлнэ.

2. DFS ашиглан бүсүүдийг олох: dfs функц нь тухайн нүднээс эхлэн холбогдсон бүх нүдний тоог тоолно. Энэ нь рекурсив ажиллаж, зэргэлдээх бүх 8 чиглэлийг шалгана.

3. Хамгийн том бүсийг тодорхойлох: Бүх бүсүүдийн хэмжээг харьцуулж, хамгийн томыг нь олно.

4. Үр дүнг хэвлэх: Хамгийн том бүсэд багтах нүдний тоог хэвлэнэ.

## Submit screenshot

![Submit](/images/14.submit.png)

