# Bear and Steady Gene


[![]( https://img.shields.io/badge/Бодлогын_линк-blue)](https://www.hackerrank.com/challenges/bear-and-steady-gene/problem?isFullScreen=true)

## Бодлогын тайлбар

Генийг A, C, T, G үсгүүдээс бүрдсэн урт нь n (4-т хуваагддаг) тэмдэгт мөрөөр илэрхийлнэ. Ген нь дээрх дөрвөн үсэг тус бүр яг n/4 удаа орсон тохиолдолд тогтвортой гэж үзнэ. Жишээлбэл, GACT ба AAGTGCT хоёулаа тогтвортой генүүд юм.

Эрдэмтэн Баавгай Лимак баавгайн ДНХ-г тогтвортой болгохын тулд засварладаг. Тэр одоо gene тэмдэгт мөрөөр илэрхийлэгдсэн генийг судалж байгаа бөгөөд энэ нь тогтвортой байх албагүй. Аз болоход Лимак gene-ийн дэд мөрийг (заримдаа хоосон) сонгон, түүнийг ямар ч ижил урттай тэмдэгт мөрөөр сольж болно.

Баавгайн генийн том хэсгийг өөрчлөх нь аюултай байж болох тул gene тэмдэгт мөр өгөгдсөн үед, Лимак тогтвортой ген болгохын тулд солих шаардлагатай хамгийн бага урттай дэд мөрийн уртыг олж туслаарай.

**Жишээ:**

gene = ACTGAAAAG гэвэл G-ийн өмнөх эсвэл дараах AA дэд мөрийг CT эсвэл TC-ээр сольж болно. Жишээ нь, ACTGACTG гэж сольж болно.

**Функцийн тодорхойлолт:**

steadyGene функцийг доорх редакторт гүйцээн бөглөнө үү. Энэ нь солих шаардлагатай хамгийн бага урттай дэд мөрийн уртыг буцаана.

steadyGene нь дараах параметртэй:

- gene: тэмдэгт мөр

**Оролтын формат:**

Эхний мөрөнд gene тэмдэгт мөрийн урт n (4-т хуваагддаг) өгөгдөнө. Хоёр дахь мөрөнд урт нь n байх gene тэмдэгт мөр өгөгдөнө.

**Хязгаарлалт:**

- 4≤n≤500,000
- n нь 4-т хуваагддаг.
- gene[i] нь A, C, G, T үсгүүдийн аль нэг нь байна.

**Гаралтын формат:**

gene-г тогтвортой болгохын тулд солих шаардлагатай хамгийн бага урттай дэд мөрийн уртыг хэвлэнэ.

**Жишээ оролт:**

```
8  
GAATAAA  
```

**Жишээ гаралт:**

```
5  
```

**Тайлбар:**

AAATA дэд мөрийг TTCCG-ээр сольсон GTTCCGAA нь тогтвортой ген болно. Солигдсон дэд мөрийн урт нь 5.

## Бодолт:

1. Тогтвортой генийн нөхцөлийг шалгах:

- Ген дэх A, C, G, T үсгүүдийн тоо тус бүр n/4 байх ёстой.

```
        int n = gene.length();
        int target = n / 4;
        int[] count = new int[26]; // A=0, C=2, G=6, T=19
        
        // Бүх үсгүүдийн тоог тоолох
        for (char c : gene.toCharArray()) {
            count[c - 'A']++;
        }
```

2. Илүүдэл үсгүүдийг тодорхойлох:

- Хэрэв аль нэг үсгийн тоо n/4-ээс их байвал тэр үсгийн илүүдэл тоог тооцоолно.

```
        if (count['A' - 'A'] == target && count['C' - 'A'] == target && 
            count['G' - 'A'] == target && count['T' - 'A'] == target) {
            return 0;
        }
        
        int left = 0;
        int minLen = n;
```

3. Хамгийн бага дэд мөрийг олох:

- Генийг туулахдаа илүүдэл үсгүүдийг агуулсан хамгийн богино дэд мөрийг олно. Энэ нь солих шаардлагатай хамгийн бага хэсэг байх болно.

```
        for (int right = 0; right < n; right++) {
            char c = gene.charAt(right);
            count[c - 'A']--;
            
            while (left <= right && 
                   count['A' - 'A'] <= target && 
                   count['C' - 'A'] <= target && 
                   count['G' - 'A'] <= target && 
                   count['T' - 'A'] <= target) {
                minLen = Math.min(minLen, right - left + 1);
                char leftChar = gene.charAt(left);
                count[leftChar - 'A']++;
                left++;
            }
        }
        
        return minLen;
```


## Submit screenshot

![Submit](/images/40.submit.png)

