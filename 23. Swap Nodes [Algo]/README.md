# Swap Nodes [Algo]

[![]( https://img.shields.io/badge/Бодлогын_линк-blue)](https://www.hackerrank.com/challenges/swap-nodes-algo/problem?isFullScreen=true)

## Бодлогын тайлбар

Хоёртын мод нь дараах шинж чанаруудын аль нэгээр тодорхойлогддог мод юм:

- Энэ нь хоосон (null) байж болно.
- Энэ нь зөвхөн үндэс зангилаа агуулж болно.
- Энэ нь үндэс зангилаа болон зүүн дэд мод, баруун дэд мод, эсвэл хоёуланг нь агуулж болно. Эдгээр дэд мод нь мөн хоёртын мод юм.

Дунд эрэмбийн аялалт (In-order traversal)-ийг дараах байдлаар гүйцэтгэнэ:

1. Зүүн дэд модыг дайрна.
2. Үндэс зангилааг зочилно.
3. Баруун дэд модыг дайрна.
\
Энэ аялалтын хувьд, үндэс зангилааны зүүн хүүгээс эхлэн зүүн дэд модыг бүрэн судална. Навчтай зангилаанд хүрэхэд эцэг зангилаа руу буцаж, баруун хүү байгаа эсэхийг шалгаад байвал түүнийг зочилно. Хэрэв баруун хүү байхгүй бол түүний зүүн ба баруун дэд модыг бүрэн судалсан гэсэн үг. Хэрэв баруун хүү байгаа бол түүний зүүн дэд мод, дараа нь баруун дэд модыг ижил аргаар дайрна. Энэ үйлдлийг бүх модыг дайрах хүртэл давтана. Дараах нөхцлүүдийн аль нэг биелэх үед л зангилааны утгыг хадгална:

- Энэ нь анхны зочилсон зангилаа, анх удаа зочилсон.
- Энэ нь навч бөгөөд зөвхөн нэг удаа зочилно.
- Түүний бүх дэд модыг судалсан, энэ нөхцөл биелэх үед зөвхөн нэг удаа зочилно.
- Энэ нь модын үндэс зангилаа бөгөөд анх удаа зочилсон.

Солих үйлдэл: Зангилааны дэд модыг солих гэдэг нь анхны зүүн дэд мод L, баруун дэд мод R байсан бол солих үед зүүн дэд мод R, баруун дэд мод L болно.

Жишээлбэл, дараах модны 1-р зангилааны хүүхдүүдийг сольё.

| |  Гүн |
|:-----|:--------:|
| 1   | 1 [1] | 
| / \   |  / \  |
| 2 3 -> 3 2 [2]   |   | 
| \   |  \  | 
| 4 5 5 4 [3]   |    |

Зүүн модын дунд эрэмбийн аялалт нь 2 4 1 3 5, баруун модынх нь 3 5 1 2 4.

**Солих үйлдлийн тодорхойлолт:**

Зангилааны гүнийг дараах байдлаар тодорхойлно:

- Үндэс зангилаа нь 1 гүнд байна.
- Эцэг зангилааны гүн d бол тухайн зангилааны гүн d+1 болно.

Мод болон k бүхэл тоо өгөгдсөн бол нэг үйлдлээр k-ийн үржвэр гүн бүрийн (h ∈ [k, 2k, 3k, ...]) зангилааны дэд модыг солино. Өөрөөр хэлбэл, h нь k-ийн үржвэр бол тухайн гүний зангилааны зүүн ба баруун дэд модыг солино.

Та n зангилаатай мод өгөгдсөн бөгөөд зангилаанууд 1-ээс n хүртэл дугаарлагдсан, үндэс нь 1-р зангилаа юм. Та t ширхэг солих үйлдлийг гүйцэтгэх бөгөөд үйлдэл бүрийн дараа модын дунд эрэмбийн аялалтыг хэвлэнэ.

**Функцийн тодорхойлолт:**

swapNodes функцийг гүйцээ. Энэ нь 2 хэмжээст бүхэл тоон массив буцаана бөгөөд элемент бүр нь солих үйлдлийн дараах дунд эрэмбийн аялалтыг илэрхийлнэ.

Параметрүүд:

- indexes: Модыг илэрхийлэх бүхэл тоон массив. node[i]-ийн зүүн ба баруун хүүхдүүдийг заадаг. Үндэс нь node[1]-ээс эхэлнэ.
- queries: Солих үйлдлийг гүйцэтгэх k утгуудын массив.

Оролтын формат:

- Эхний мөрөнд n (модын зангилааны тоо) байна.
- Дараагийн n мөр бүрт a b (зангилааны зүүн ба баруун хүүхдийн индекс) байна. -1 нь хоосон зангилааг илэрхийлнэ.
- Дараагийн мөрөнд t (солих үйлдлийн тоо) байна.
- Дараагийн t мөр бүрт k (солих гүн) байна.

**Гаралтын формат:**

- k бүрийн дараа дунд эрэмбийн аялалтыг хэвлэ.

## Бодолт:

Тайлбар:

1. Мод бүтээх: buildTree функц нь indexes-ийг ашиглан модыг BFS аргаар бүтээдэг.

```
    private static Node buildTree(List<List<Integer>> indexes) {
        Node root = new Node(1);
        Queue<Node> queue = new LinkedList<>();
        queue.add(root);
        for (List<Integer> children : indexes) {
            Node current = queue.poll();
            int left = children.get(0);
            int right = children.get(1);
            if (left != -1) {
                current.left = new Node(left);
                queue.add(current.left);
            }
            if (right != -1) {
                current.right = new Node(right);
                queue.add(current.right);
            }
        }
        return root;
    }

```

2. Солих: swap функц нь BFS ашиглан гүн бүрт k-ийн үржвэр гүнтэй зангилааны хүүхдүүдийг солино.

```
    private static void swap(Node root, int k) {
        Queue<Node> queue = new LinkedList<>();
        queue.add(root);
        int depth = 1;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                Node current = queue.poll();
                if (depth % k == 0) {
                    Node temp = current.left;
                    current.left = current.right;
                    current.right = temp;
                }
                if (current.left != null) queue.add(current.left);
                if (current.right != null) queue.add(current.right);
            }
            depth++;
        }
    }
```

3. Дунд эрэмбийн аялалт: inOrder функц нь рекурсив аргаар модыг дайрч үр дүнг traversal-д хадгална.

```
    private static void inOrder(Node root, List<Integer> traversal) {
        if (root == null) return;
        inOrder(root.left, traversal);
        traversal.add(root.data);
        inOrder(root.right, traversal);
    }
```



## Submit screenshot

![Submit](/images/23.submit.png)

